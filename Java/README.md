# Java
Java의 정석을 바탕으로 공부하였다. 다른 프로그래밍언어를 어느정도 다루어 봤다는 전제로 자바에서 다른 내용들이나 헷갈릴 수 있을 내용들을 위주로 작성하였다.
# 목차



# 자바를 시작하기 전에
## JVM(Java Virtual Machine)
* JVM은 자바를 실행하기 위한 가상 기계이다. 컴퓨터 속의 컴퓨터로 자바로 작성된 **모든** 어플리케이션은 모두 JVM에서만 실행된다.

* 일반적인 애플리케이션은 OS를 거쳐 바로 하드웨어로 전달된다. 하지만 자바애플리케이션은 JVM을 거치고 실행 시에 코드가 해석되기 때문에 속도가 느리다.

* 일반 애플리케이션은 바로 OS와 맞붙어 있기에 OS종속적이다. 하지만 자바애플리케이션은 JVM을 이용하기에 OS에 맞는 JVM만 있으면 어떤 OS에서도 실행 가능하다.

## VS Code에 JDK 설치하기
* [link](https://niceman.tistory.com/198)를 참고하여 설치를 진행하였다.

* JDK의 bin 디렉터리에 있는 파일들을 살펴보자.
  * `javac.exe` : 자바 컴파일러, 자바소스코드를 바이트코드로 컴파일한다.

  * `java.exe` : 자바 인터프리터, 컴파일러가 생성한 바이트코드를 해석하고 실행한다.

  * `javap.exe` : 역어셈블러, 컴파일된 클래스파일을 원래의 소스로 변환한다.

  * `javadoc.exe` : 자동 문서 생성기, 소스파일에 있는 주석을 이용하여 Java API문서와 같은 형식의 문서를 자동으로 생성한다.

  * `jar.exe` : 압축프로그램, 클래스파일과 프로그램의 실행에 관련된 파일을 jar파일로 압축하거나 압축해제한다.

## 자바 프로그램 실행하기
* 먼저 `Hello.java`를 작성한다. 윈도우의 경우 cmd를 열어 `javac Hello.java`를 입력하면 `Hello.class`가 생성된다. `java Hello`를 통해 이제 소스코드가 실행된다.

* 자바에서 모든 코드는 반드시 클래스 안에 존재해야 한다. 유사한 기능들의 코드가 그룹을 이루고 클래스를 형성한다.

* 클래스를 작성하는 방법은 키워드 `class`다음에 클래스의 이름을 적고 `{}` 안에 코드를 작성하면 된다.

* C언어와 비슷하게 `main`메서드부터 실행하며 모든 클래스가 `main`메서드를 가질 필요는 없지만 하나의 자바 애플리케이션에는 `main`메서드를 포함한 클래스가 반드시 하나는 있어야 한다. 자바 애플리케이션을 실행할 때는 `java.exe` 다음에 `main`메서드를 포함한 클래스의 이름을 적어야 한다.
  * `main`메서드는 `public static void main (String[] args)`와 같이 선언해야한다. 이는 `java.exe`에 의해 호출될 수 있도록 미리 약속한 부분이다.

* 하나의 소스파일에 여러 개의 클래스를 정의할 수 있다. 하지만 이 때 소스파일의 이름은 반드시 `public class`의 이름과 같아야 한다. `public class`가 없다면 소스파일의 이름은 소스파일 내의 어떤 클래스의 이름으로 해도 된다.

* 하나의 소스파일에 둘 이상의 `public class`가 존재해선 안된다.

## 자바프로그램의 실행과정
* 콘솔에서 `java Hello` 명령을 실행하면 내부적인 진행 순서는 다음과 같다.    
  1. 프로그램의 실행에 필요한 클래스를 로드한다.     
  2. 클래스파일을 검사한다.    
  3. 지정된 클래스에서 main을 호출한다. 
***

# 변수 Variable
## 변수의 선언과 초기화
* 변수의 선언, 초기화 방법은 C언어와 같다. 

## 변수의 명명규칙
1. 대소문자가 구분되며 길이에 제한이 없다.
2. 예약어를 사용해선 안 된다.
3. 숫자로 시작해서는 안 된다.
4. 특수문자는 `_`와 `$`만 허용된다.

* 다음의 규칙들은 자바 프로그래머들에게 권장되는 규칙이다.
  1. 클래스의 이름의 첫 글자는 항상 대문자로 한다.
      * 변수와 메서드는 소문자로 한다.
  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. 
      * StringBuffer ...
  3. 상수의 이름은 모두 대문자로 한다. 띄어쓰기는 `_`로 구분한다.

## 참조형 변수
* 변수의 타입은 기본형 변수와 참조형 변수로 나뉜다.
  * 기본형 변수는 **실제 값**을 저장한다.

  * 참조형 변수는 C의 포인터처럼 어떤 값이 저장되어 있는 **주소**를 값으로 갖는다. 단, C와 달리 참조형 변수간의 연산은 할 수 없다.

* 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.

* `classname variablename`과 같이 선언하며 이 때 변수의 타입이 기본형이 아닌 것들은 **모두 참조변수**이다.

## 기본형 변수
* 기본형 변수는 C++와 비슷하게 `boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double`를 지원한다. 

* `boolean`은 참, 거짓을 저장하며 나머지 자료형들과 연산과 변환이 불가능하다.

* 기본 자료형의 크기는 모두 외워두자.    
  boolean : 1 byte   
  char : 2 byte   
  byte : 1 byte   
  short : 2 byte   
  int : 4 byte   
  long : 4 byte   
  float : 4 byte   
  double : 8 byte   

## 상수와 리터럴
* `final` 키워드로 상수를 선언할 수 있다.   
`final int MAX = 10;`

* 이 때 `MAX`를 상수라 하고, `10`을 리터럴이라 한다.

* 리터럴을 저장할 때 `1_000`과 같이 `_`를 중간에 넣어서 자릿수를 구분할 수 있다.

* 리터럴 또한 타입을 정할 수 있다. 접미사로 `L` 또는 `l`을 붙이면 정수형 `long`타입이 되고 `f`, `d`를 붙이면 실수형 `float`, `double` 타입이 된다.
  * 리터럴 타입을 지정하지 않으면 정수형의 경우 `long`타입으로, 실수형의 경우 `double`타입이 디폴트로 지정된다. 이 때 `float pi = 3.14;`와 같이 사용하면 `float` 변수에 `double` 리터럴을 저장하므로 컴파일 에러가 발생한다.

  * 16진수 표기는 접두사 `0x`를, 8진수는 `0`을 붙인다. 2진수는 `0b`를 붙인다.

## 문자 리터럴과 문자열 리터럴
* 문자열 객체를 지원하며 덧셈 연산자로 문자열을 결합할 수 있다.
  * 이 때 문자열과 결합되는 다른 **모든 타입**은 문자열로 변환한다.

  * 이를 이용해서 `(int)7`을 `7 + ""`과 같이 실행하여 문자열 7로 바꿀 수 있다.

  * 
    ```
    String name = "Java";
    String str = name + 16.0;
    ```
    위의 코드에서 `str`을 출력하면 `Java16.0`이 출력된다.

## 출력 - printf()
* `println()`을 사용하여 출력하면 변수의 값을 그대로 출력하고 자동으로 줄바꿈을 한다. 그러나 실수를 소수점 둘째자리까지 출력한다던가, 정수를 16진수로 출력하는 등 변수의 타입과는 다른 형식으로 출력하고 싶을 때 `printf`를 이용할 수 있다.

* `printf`는 C언어와 같은 형식으로 사용하며 형식 지정자 또한 같다.   
  %b : 불리언 형식   
  %d : 10진수 정수
  %o : 8진수 정수   
  %x : 16진수 정수   
  %f : 부동 소수점 실수   
  %e : 지수 표현   
  %c : 문자   
  %s : 문자열   
  2진수 출력은 지원하지 않으므로 따로 메서드를 사용해야 한다.

* `%5d`와 같이 사용하면 필드 5칸을 확보해서 오른쪽 정렬하여 출력한다.   
`%-5d`와 같이 사용하면 필드 5칸을 확보해서 왼쪽 정렬하여 출력한다.   
`%05d`와 같이 사용하면 필드 5칸을 확보해서 공백을 0으로 채워 출력한다.   
`%14.10f`와 같이 사용하면 전체 14자리 중 소수점 아래 10자리만 출력한다.   
`%.8s`와 같이 사용하면 문자열을 왼쪽에서 8글자만 출력한다.

* 형식 지정자 `%x`와 `%o`에 `#`을 사용하면 접두사 `0x`와 `0`을 붙여서 출력한다.

* C언어에서는 `char`타입을 `%d`로 출력할 수 있지만 자바에서는 꼭 형변환 후에 출력해야 한다.

## 입력 - Scanner
* `Scanner`클래스를 이용하여 화면에서 입력받을 수 있다.

* `import java.util.*;`과 같이 사용하여 `Scanner`클래스를 사용할 수 있다.

* `Scanner sc = new Scanner(System.in);`과 같이 `Scanner`객체를 생성한다.

## 정수형의 표현형식과 범위
* 모든 정수형은 부호있는 정수이므로 가장 왼쪽의 비트를 부호 비트로 사용한다. 따라서 n비트 정수형 자료형은 $-2^{n-1}$ ~ $2^{n-1} - 1$의 값을 표현할 수 있다.
  * 그러므로 다뤄야할 정수가 `int`의 범위(약 $\pm 20$억)를 넘어간다면 `long`를 사용할 수 있다.
***

# 연산자 Operator
## 연산자의 우선순위와 결합규칙
* 논리 연산자 `AND`는 `OR`보다 우선순위가 높으므로 둘 다 사용되는 경우 괄호를 사용하자.

* 대입연산자의 경우 결합규칙이 오른쪽에서 왼쪽이다. 따라서 `x = y = 3`과 같은 문장이 가능하다.

## 연산자와 형변환
* 같은 정수형, 실수형 변수더라도 크기가 다른 타입끼리 연산을 하는 경우 꼭 결과를 명시적으로 형변환해주자.   
  ```
  int a = 1_000_000;
  int b = 2_000_000;

  long c = a * b; //잘못된 문장
  long c = (long)a * b //옳은 문장
  ```

* 정수형 숫자들의 연산 결과는 기본적으로 `int`기 때문에 연산의 결과가 `int`의 범위를 넘는 경우 `long a = 1_000_000 * 1_000_000L`과 같이 사용해야 한다.

* 정수형 나눗셈의 경우 무조건 **버림**한다. 이를 **반올림**으로 바꾸려면 0.5를 더하고 나눠주면 된다.
  * 버림 예시
    ```
    float pi = 3.141592f;
    float shortPi = (int)(pi * 1000) / 1000f; 
    ```

  * 반올림 예시
    ```
    float pi = 3.141592f;
    float shorPi = (int)(pi * 1000 + 0.5) / 1000.0;
    ```

* `float`타입과 `double`타입을 비교할 때는 정밀도 차이에 의해 많은 오류가 발생할 수 있다. 따라서 꼭 `double`타입을 `float`타입으로 변환하여 비교해야 한다. 
  * `float`타입을 `double`타입으로 변경하면 그저 가수를 늘리고 0으로 채울 뿐이므로 정밀도는 전혀 향상되지 않는다.

## 문자열 비교
* `==`을 사용해서 비교할 수 있다. `==`을 사용하는 경우 객체의 문자열을 비교하는 것이 아닌, 객체가 완전히 같은지만 비교하기 때문에 같은 문자열이라도 `new`를 사용했는지, 아닌지에 따라 결과가 달라지기에 권장하지 않는다.

* `equals()`메서드를 사용하면 쉽게 비교할 수 있다.
  * `s1.equals(s2);`와 같이 사용하며 문자열이 같으면 `true`를 아니라면 `false`를 리턴한다.
`
## 비트연산자
* `|` : OR연산자   
`&` : AND연산자, 1로 AND를 한 비트만 뽑아낼 수 있다.   
`^` : XOR연산자, 같은 값을 두고 XOR을 사용하면 원래 값을 리턴한다.   
`~` : 비트 전환 연산자   
`<<` : 왼쪽으로 비트 이동, 빈자리는 0으로 채워진다.   
  * `x << n`은 $x * 2^n$과 같다.

  `>>` : 오른쪽으로 비트 이동, 빈자리는 0으로 채워진다.   
    * `x >> n`은 $x / 2^n$과 같다.