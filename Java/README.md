# Java

Java의 정석을 바탕으로 공부하였다. 다른 프로그래밍언어를 어느정도 다루어 봤다는 전제로 자바에서 다른 내용들이나 헷갈릴 수 있을 내용들을 위주로 작성하였다.

# 목차

# 자바를 시작하기 전에

## JVM(Java Virtual Machine)

- JVM은 자바를 실행하기 위한 가상 기계이다. 컴퓨터 속의 컴퓨터로 자바로 작성된 **모든** 어플리케이션은 모두 JVM에서만 실행된다.

- 일반적인 애플리케이션은 OS를 거쳐 바로 하드웨어로 전달된다. 하지만 자바애플리케이션은 JVM을 거치고 실행 시에 코드가 해석되기 때문에 속도가 느리다.

- 일반 애플리케이션은 바로 OS와 맞붙어 있기에 OS종속적이다. 하지만 자바애플리케이션은 JVM을 이용하기에 OS에 맞는 JVM만 있으면 어떤 OS에서도 실행 가능하다.

## VS Code에 JDK 설치하기

- [link](https://niceman.tistory.com/198)를 참고하여 설치를 진행하였다.

- JDK의 bin 디렉터리에 있는 파일들을 살펴보자.

  - `javac.exe` : 자바 컴파일러, 자바소스코드를 바이트코드로 컴파일한다.

  - `java.exe` : 자바 인터프리터, 컴파일러가 생성한 바이트코드를 해석하고 실행한다.

  - `javap.exe` : 역어셈블러, 컴파일된 클래스파일을 원래의 소스로 변환한다.

  - `javadoc.exe` : 자동 문서 생성기, 소스파일에 있는 주석을 이용하여 Java API문서와 같은 형식의 문서를 자동으로 생성한다.

  - `jar.exe` : 압축프로그램, 클래스파일과 프로그램의 실행에 관련된 파일을 jar파일로 압축하거나 압축해제한다.

## 자바 프로그램 실행하기

- 먼저 `Hello.java`를 작성한다. 윈도우의 경우 cmd를 열어 `javac Hello.java`를 입력하면 `Hello.class`가 생성된다. `java Hello`를 통해 이제 소스코드가 실행된다.

- 자바에서 모든 코드는 반드시 클래스 안에 존재해야 한다. 유사한 기능들의 코드가 그룹을 이루고 클래스를 형성한다.

- 클래스를 작성하는 방법은 키워드 `class`다음에 클래스의 이름을 적고 `{}` 안에 코드를 작성하면 된다.

- C언어와 비슷하게 `main`메서드부터 실행하며 모든 클래스가 `main`메서드를 가질 필요는 없지만 하나의 자바 애플리케이션에는 `main`메서드를 포함한 클래스가 반드시 하나는 있어야 한다. 자바 애플리케이션을 실행할 때는 `java.exe` 다음에 `main`메서드를 포함한 클래스의 이름을 적어야 한다.

  - `main`메서드는 `public static void main (String[] args)`와 같이 선언해야한다. 이는 `java.exe`에 의해 호출될 수 있도록 미리 약속한 부분이다.

- 하나의 소스파일에 여러 개의 클래스를 정의할 수 있다. 하지만 이 때 소스파일의 이름은 반드시 `public class`의 이름과 같아야 한다. `public class`가 없다면 소스파일의 이름은 소스파일 내의 어떤 클래스의 이름으로 해도 된다.

- 하나의 소스파일에 둘 이상의 `public class`가 존재해선 안된다.

## 자바프로그램의 실행과정

- 콘솔에서 `java Hello` 명령을 실행하면 내부적인 진행 순서는 다음과 같다.
  1. 프로그램의 실행에 필요한 클래스를 로드한다.
  2. 클래스파일을 검사한다.
  3. 지정된 클래스에서 main을 호출한다.

---

# 변수 Variable

## 변수의 선언과 초기화

- 변수의 선언, 초기화 방법은 C언어와 같다.

## 변수의 명명규칙

1. 대소문자가 구분되며 길이에 제한이 없다.
2. 예약어를 사용해선 안 된다.
3. 숫자로 시작해서는 안 된다.
4. 특수문자는 `_`와 `$`만 허용된다.

- 다음의 규칙들은 자바 프로그래머들에게 권장되는 규칙이다.
  1. 클래스의 이름의 첫 글자는 항상 대문자로 한다.
     - 변수와 메서드는 소문자로 한다.
  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
     - StringBuffer ...
  3. 상수의 이름은 모두 대문자로 한다. 띄어쓰기는 `_`로 구분한다.

## 참조형 변수

- 변수의 타입은 기본형 변수와 참조형 변수로 나뉜다.

  - 기본형 변수는 **실제 값**을 저장한다.

  - 참조형 변수는 C의 포인터처럼 어떤 값이 저장되어 있는 **주소**를 값으로 갖는다. 단, C와 달리 참조형 변수간의 연산은 할 수 없다.

- 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.

- `classname variablename`과 같이 선언하며 이 때 변수의 타입이 기본형이 아닌 것들은 **모두 참조변수**이다.

## 기본형 변수

- 기본형 변수는 C++와 비슷하게 `boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double`를 지원한다.

- `boolean`은 참, 거짓을 저장하며 나머지 자료형들과 연산과 변환이 불가능하다.

- 기본 자료형의 크기는 모두 외워두자.  
  boolean : 1 byte  
  char : 2 byte  
  byte : 1 byte  
  short : 2 byte  
  int : 4 byte  
  long : 4 byte  
  float : 4 byte  
  double : 8 byte

## 상수와 리터럴

- `final` 키워드로 상수를 선언할 수 있다.  
  `final int MAX = 10;`

- 이 때 `MAX`를 상수라 하고, `10`을 리터럴이라 한다.

- 리터럴을 저장할 때 `1_000`과 같이 `_`를 중간에 넣어서 자릿수를 구분할 수 있다.

- 리터럴 또한 타입을 정할 수 있다. 접미사로 `L` 또는 `l`을 붙이면 정수형 `long`타입이 되고 `f`, `d`를 붙이면 실수형 `float`, `double` 타입이 된다.

  - 리터럴 타입을 지정하지 않으면 정수형의 경우 `long`타입으로, 실수형의 경우 `double`타입이 디폴트로 지정된다. 이 때 `float pi = 3.14;`와 같이 사용하면 `float` 변수에 `double` 리터럴을 저장하므로 컴파일 에러가 발생한다.

  - 16진수 표기는 접두사 `0x`를, 8진수는 `0`을 붙인다. 2진수는 `0b`를 붙인다.

## 문자 리터럴과 문자열 리터럴

- 문자열 객체를 지원하며 덧셈 연산자로 문자열을 결합할 수 있다.

  - 이 때 문자열과 결합되는 다른 **모든 타입**은 문자열로 변환한다.

  - 이를 이용해서 `(int)7`을 `7 + ""`과 같이 실행하여 문자열 7로 바꿀 수 있다.

  - ```
    String name = "Java";
    String str = name + 16.0;
    ```
    위의 코드에서 `str`을 출력하면 `Java16.0`이 출력된다.

## 임의의 값 생성하기

- `Math.random()`을 사용하면 0.0 이상 1.0 미만의 double 값을 리턴한다. 따라서 0 ~ 9 사이의 정수형 난수를 만드려면 `(int)Math.random() * 10`과 같이 사용하면 된다.

## 출력 - printf()

- `println()`을 사용하여 출력하면 변수의 값을 그대로 출력하고 자동으로 줄바꿈을 한다. 그러나 실수를 소수점 둘째자리까지 출력한다던가, 정수를 16진수로 출력하는 등 변수의 타입과는 다른 형식으로 출력하고 싶을 때 `printf`를 이용할 수 있다.

- `printf`는 C언어와 같은 형식으로 사용하며 형식 지정자 또한 같다.  
  %b : 불리언 형식  
  %d : 10진수 정수
  %o : 8진수 정수  
  %x : 16진수 정수  
  %f : 부동 소수점 실수  
  %e : 지수 표현  
  %c : 문자  
  %s : 문자열  
  2진수 출력은 지원하지 않으므로 따로 메서드를 사용해야 한다.

- `%5d`와 같이 사용하면 필드 5칸을 확보해서 오른쪽 정렬하여 출력한다.  
  `%-5d`와 같이 사용하면 필드 5칸을 확보해서 왼쪽 정렬하여 출력한다.  
  `%05d`와 같이 사용하면 필드 5칸을 확보해서 공백을 0으로 채워 출력한다.  
  `%14.10f`와 같이 사용하면 전체 14자리 중 소수점 아래 10자리만 출력한다.  
  `%.8s`와 같이 사용하면 문자열을 왼쪽에서 8글자만 출력한다.

- 형식 지정자 `%x`와 `%o`에 `#`을 사용하면 접두사 `0x`와 `0`을 붙여서 출력한다.

- C언어에서는 `char`타입을 `%d`로 출력할 수 있지만 자바에서는 꼭 형변환 후에 출력해야 한다.

## 입력 - Scanner

- `Scanner`클래스를 이용하여 화면에서 입력받을 수 있다.

- `import java.util.*;`과 같이 사용하여 `Scanner`클래스를 사용할 수 있다.

- `Scanner sc = new Scanner(System.in);`과 같이 `Scanner`객체를 생성한다.

- 주요 메소드

  - next( ) : 문자열을 띄어쓰기로 구분하여 리턴한다.

  - nextLine( ) : `\n`이 나오기 전까지의 문자열을 모두 리턴한다. `\n`은 버린다.

  - nextInt( ) : 정수를 띄어쓰기로 구분하여 리턴한다. 다른 타입에 대해서도 `nexttypename`으로 사용 가능하다. 마지막에 들어오는 `\n`은 무시하므로 버퍼를 비워줘야 한다.

    - `sc.nextLine();`와 같이 사용하면 버퍼를 비울 수 있다.

  - close( ) : `Scanner`의 사용을 종료한다. 마지막에 꼭 붙여주자.

  - hasNext( ) : 현재 입력된 토큰이 있으면 true, 아니면 새로운 입력이 들어올 때 까지 기다린다. 터미널이 종료되면 종료된다.

## 정수형의 표현형식과 범위

- 모든 정수형은 부호있는 정수이므로 가장 왼쪽의 비트를 부호 비트로 사용한다. 따라서 n비트 정수형 자료형은 $-2^{n-1}$ ~ $2^{n-1} - 1$의 값을 표현할 수 있다.
  - 그러므로 다뤄야할 정수가 `int`의 범위(약 $\pm 20$억)를 넘어간다면 `long`를 사용할 수 있다.

---

# 연산자 Operator

## 연산자의 우선순위와 결합규칙

- 논리 연산자 `AND`는 `OR`보다 우선순위가 높으므로 둘 다 사용되는 경우 괄호를 사용하자.

- 대입연산자의 경우 결합규칙이 오른쪽에서 왼쪽이다. 따라서 `x = y = 3`과 같은 문장이 가능하다.

## 연산자와 형변환

- 같은 정수형, 실수형 변수더라도 크기가 다른 타입끼리 연산을 하는 경우 꼭 결과를 명시적으로 형변환해주자.

  ```
  int a = 1_000_000;
  int b = 2_000_000;

  long c = a * b; //잘못된 문장
  long c = (long)a * b //옳은 문장
  ```

- 정수형 숫자들의 연산 결과는 기본적으로 `int`기 때문에 연산의 결과가 `int`의 범위를 넘는 경우 `long a = 1_000_000 * 1_000_000L`과 같이 사용해야 한다.

- 정수형 나눗셈의 경우 무조건 **버림**한다. 이를 **반올림**으로 바꾸려면 0.5를 더하고 나눠주면 된다.

  - 버림 예시

    ```
    float pi = 3.141592f;
    float shortPi = (int)(pi * 1000) / 1000f;
    ```

  - 반올림 예시
    ```
    float pi = 3.141592f;
    float shorPi = (int)(pi * 1000 + 0.5) / 1000.0;
    ```

- `float`타입과 `double`타입을 비교할 때는 정밀도 차이에 의해 많은 오류가 발생할 수 있다. 따라서 꼭 `double`타입을 `float`타입으로 변환하여 비교해야 한다.
  - `float`타입을 `double`타입으로 변경하면 그저 가수를 늘리고 0으로 채울 뿐이므로 정밀도는 전혀 향상되지 않는다.

## 문자열 비교

- `==`을 사용해서 비교할 수 있다. `==`을 사용하는 경우 객체의 문자열을 비교하는 것이 아닌, 객체가 완전히 같은지만 비교하기 때문에 같은 문자열이라도 `new`를 사용했는지, 아닌지에 따라 결과가 달라지기에 권장하지 않는다.

- `equals()`메서드를 사용하면 쉽게 비교할 수 있다.
  - `s1.equals(s2);`와 같이 사용하며 문자열이 같으면 `true`를 아니라면 `false`를 리턴한다.

## 비트연산자

- `|` : OR연산자  
  `&` : AND연산자, 1로 AND를 한 비트만 뽑아낼 수 있다.  
  `^` : XOR연산자, 같은 값을 두고 XOR을 사용하면 원래 값을 리턴한다.  
  `~` : 비트 전환 연산자  
  `<<` : 왼쪽으로 비트 이동, 빈자리는 0으로 채워진다.

  - `x << n`은 $x * 2^n$과 같다.

  `>>` : 오른쪽으로 비트 이동, 빈자리는 0으로 채워진다.  
   \* `x >> n`은 $x / 2^n$과 같다.

---

# 조건문과 반복문

## switch문의 제약조건

- `switch`문의 조건식 결과는 정수 또는 문자열이어야 한다.

- `case`문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.

## 향상된 for문

- `for-each`또한 지원한다. C++의 `ranged-for-loop`와 사용법은 같다.

  - ```
    for(int i : arr){

    }
    ```

## 이름 붙은 반복문

- 알고리즘을 짜다보면 중첩된 반복문을 한 번에 break하고싶은 상황이 생긴다. 이 때 반복문에 이름을 붙이고 break문이나 continue문에 이름을 붙여서 한 번에 중단할 수 있다.
  - ```
    class named-for{
      public static void main(String[] args){
        Loop1 : for(int i = 2; i <= 9; i++){
              for(int j = 1; j <= 9; j++){
                if(j == 5) break Loop1;
              System.out.printLn(i+j);
              }
        }
      }
    }
    ```

---

# 배열 Array

## 배열의 선언과 생성

- `타입[] 변수이름;`과 같이 배열을 선언한다.

  - `int[] score;`

- `변수이름 = new 타입[길이]`와 같이 배열을 생성한다.

  - `score = new int[5];`

  - `int[] score = new int[5];`도 가능하다.

- 기본적으로 0으로 초기화된다.

- 배열의 길이는 0이어도 된다.

- `배열 이름.length` : 배열의 길이 리턴

## 배열의 길이 변경하기

1. 더 큰 배열을 새로 생성한다.

2. 기존 배열의 내용을 새로운 배열에 복사한다.

- 위의 과정을 통해 배열의 길이를 변경할 수 있지많 많은 비용이 발생한다.

## 배열의 초기화

- 기본적으로 배열을 생성할 때 초기화할 수 있다. 하지만 이 경우 `new int[]`는 생략할 수 없다.

  - ```
    int[] score;
    score = new int[]{50, 60, 70};
    ```

- 배열의 선언과 생성을 동시에 할 때는 `new int[]`를 생략할 수 있다.

  - ```
    int []score = new int[]{50, 60, 70};
    int []score2 = {50, 60, 70};
    ```

- 메서드를 호출해야하는 경우 `new int[]`를 생략할 수 없다.

  - ```
    int res = add(new int[]{10, 20, 30});
    ```

## 배열의 출력

- 배열이 가리키는 값이 아닌, 배열 자체를 출력하면 `타입@주소`의 형식으로 출력된다.

  - `[I@14318bb`와 같이 출력되며 `[I`는 1차원 int배열이라는 뜻이고 뒤의 숫자는 16진수이다.

  - 예외적으로 `println`을 통해 char형 배열 자체를 출력하면 각 요소가 구분자없이 문자열처럼 출력된다.

- `Arrays.toString(배열이름)` 메서드는 배열의 요소들을 `[arr[1], arr[2], ...]`과 같이 만들어서 리턴하므로 출력할 때 이용하기 편하다.

  - ```
    int[] Arr = {10, 20, 30, 40};
    System.out.println(Arrays.toString(Arr));
    ```
    과 같이 사용하면 `[10, 20, 30, 40]`이 출력된다.

## 배열의 복사

- ```
  int[] arr = new int[5];
  int[] tmp = new int[arr.length*2];
  for(int i=0;i < arr.length;i++)
    tmp[i] = arr[i];

  arr = temp;
  ```

  위와 같이 배열의 길이를 늘려서 복사할 수 있으며 `arr = tmp`는 참조변수 `arr`이 새로운 배열을 가리키게 한다.

- `System.arraycopy()`를 사용하는 것이 더 효율적이다.
  `System.arraycopy(num, 0, newNum, 0, num.length);`  
  위와 같이 사용하면 배열`num[0]`에서 배열`newNum[0]`으로 `num.length`만큼 복사한다는 듯이다.

## String 클래스

- 문자배열로도 초기화할 수 있다.

  - ```
    char[] chArr = {'A', 'B'};
    String str = new String(chArr);
    ```

- String클래스는 char배열에 메서드를 추가한 객체이다.

- String객체는 읽을 수만 있고 내용을 변경할 수 없다. 그저 새로운 내용의 문자열을 생성할 수 있다.

- String클래스의 간단한 메서드만 보자.

  - `char charAt(int index)` : 문자열에서 해당 index에 있는 문자를 반환한다.

  - `String substring(int from, int to)` : 문자열에서 `from ~ to`범위의 문자열을 반환한다. 이 때 `to`는 범위에 포함되지 않는다.

  - `boolean equals(Object obj)` : 문자열의 내용이 obj와 같은지 확인한다.

  - `char[] toCharArray()` : 문자열을 char배열로 변환해서 반환한다.

## String배열의 초기화

- String은 기본적으로 null로 초기화된다.

- String은 클래스이므로 `String[] name = new String[2]`만 수행하면 `name`이라는 참조변수 배열(사이즈 2)만 생성 되었다. 따라서

  ```
  String[] name = new String[2];
  name[0] = new String("Kim");
  ```

  과 같이 초기화해야하지만 간략하게 초기화하는 방법이 허용된다.

  ```
  String[] name = new String[2];
  name[0] = "Kim";
  ```

- String 또한 문자열이 저장되어있는 주소를 저장하는 참조형 변수이다. "따라서 `name[0]`에는 `"Kim"`을 가리키는 주소가 저장되어있고 거기로 가면 `"Kim"`이 있는 주소가 저장되어있다. 이는 C의 이중포인터와 비슷한 방법이라 이해하면 된다.

## 커맨드 라인을 통해 입력받기

- 프로그램을 실행할 때 클래스 이름 뒤에 공백문자로 구분하여 여러 개의 문자열을 프로그램에 전달할 수 있다.

  - main메서드가 담긴 클래스의 이름 뒤에 문자열을 전달할 수 있고, 이는 main메서드 내에서 `args`로 전달하는 String배열에 전달되는 것이다.

  - `c:\jdk1.8\work\ch5>hava MainTest abc 123` 과 같이 사용하면 `args[0] = "abc"`이고 `args[1] = "123"`이다.

    - 이 때 문자열 "123"을 숫자 123으로 바꾸려면 `int num = Integer.parseInt("123");`과 같이 할 수 있다.

# 다차원 배열

## 2차원 배열의 선언

- `타입[][] 변수이름;`과 같이 선언한다.

  - `int[][] score;`

- `타입 변수이름[][];`으로도 선언할 수 있다.

  - `int score[][];`

- 참조 변수를 선언한 뒤 `new`로 생성해야 한다.

  - `int score[][] = new int[2][3];`

## 향상된 for문을 통한 2차원 배열 접근

- ```
  for(int[] i : score)
    for(int j : i)
      ...
  ```
  과 같이 사용한다. 이 때 `int[]`를 사용하므로써 배열의 한 행에 접근한다.

## 가변 배열

- 자바에서는 다차원 배열을 **배열의 배열**의 형태로 처리한다. 따라서 각 행마다 열의 길이를 다르게 선언할 수 있다.

  - ```
    int[][] score = new int[2][];
    score[0] = new int[3];
    score[1] = new int[5];
    ```

    더 간략하게도 생성할 수 있다.

  - ```
    int[][] score = {
      {100, 100, 100}
    , {1, 2, 3, 4, 5}
    };
    ```

---

# 객체지향 프로그래밍Ⅰ

## 인스턴스의 생성과 사용

- ```
  클래스명 변수명;
  변수명 = new 클래스명();
  ```

  과 같이 인스턴스를 생성할 수 있다.

  - `Tv t;`를 수행하면 `Tv`클래스 타입의 참조변수 `t`를 선언한다. 이 때 `t`는 아직 인스턴스를 가리키지 않으므로 비어있다.

  - `t = new Tv();`를 수행하면 `Tv`클래스의 인스턴스를 메모리의 빈 공간에 생성하고 참조변수 `t`가 그 메모리를 가리킨다.

  - ```
    Tv t1 = new Tv();
    Tv t2 = new Tv();
    ```
    위의 코드를 실행하면 `Tv`클래스의 인스턴스가 서로 다른 공간에 두 개가 생성된다. 그리고 `t2 = t1;`을 하면 참조변수 `t2`가 `t1`이 가리키는 메모리 영역을 가리키게 된다. 따라서 기존에 `t2`가 가리키고 있던 메모리 영역은 접근할 수 없다.

## 객체 배열

- `Tv[] tvArr = new Tv[3];`과 같이 객체 배열을 생성할 수 있다. 이 때 `tvArr`은 아직 참조변수 배열만 생성 된 것이다. 따라서 각 원소는 **참조변수의 기본값인 null**로 초기화된다.

- ```
  Tv[] tvArr = new Tv[3];
  for(int i=0;i<tvArr.length;i++)
    tvArr[i] = new Tv();
  ```
  혹은
  ```
  Tv[] tvArr = new Tv[3];
  Tv tvArr = {new Tv(),
              new Tv(),
              new Tv()};
  ```
  와 같이 객체 배열을 생성하여 사용할 수 있다.

## 멤버 변수

- 인스턴스 변수

  - 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.

- 클래스 변수

  - 클래스 영역에 `static`을 붙여 선언된 변수이다. 인스턴스에 소속되지 않고 모든 인스턴스가 공통으로 사용한다. 따라서 클래스가 메모리에 올라가면 생성된다.

  - `Variables` 클래스의 클래스 변수 `cv`를 사용하려면 `Variables.cv`와 같이 사용한다.

- 지역변수

  - 클래스 영역 이외에 메서드, 생성자, 초기화 블럭 내부 등에 선언된 변수이다.

---

## JVM의 메모리 구조

- 메서드 영역

  - 프로그램 실행 중 어떤 클래스가 사용되면, 해당 클래스파일을 읽어서 분석하여 클래스 데이터를 메서드 영역에 저장한다. 클래스변수 또한 이 영역에 저장된다.

- 힙

  - 인스턴스들이 힙에 생성된다. 메서드가 작업을 마치면 할당되었던 공간은 반환되어 비어진다.

  - 호출스택의 제일 위에 있는 메모리가 현재 실행 중인 메서드이다.

  - 메서드를 호출한 순서대로 아래에 깔린다.

## 기본형 매개변수와 참조형 매개변수

- 기본형 매개변수는 값을 읽기만 할 수 있다.

- 참조형 매개변수는 값을 읽고 쓸 수 있다.

- 기본형 매개변수를 메서드에 매개변수로 사용하면 값의 복사만 일어나서 그 매개변수를 변경해도 원본은 변경되지 않는다.

- 반환타입이 **참조형**이면 메서드가 **객체의 주소**를 반환한다는 것을 의미한다.

## 클래스 멤버와 인스턴스 멤버간의 참조와 호출

- 같은 클래스에 속한 멤버들끼리는 별도의 인스턴스 생성 없이도 서로를 참조, 호출이 가능하다.

  - 단, 클래스멤버가 인스턴스 멤버를 참조, 호출하려면 인스턴스를 생성해야 한다.

  - 인스턴스 멤버가 존재하는 시점에는 클래스 멤버가 항상 존재한다.

  - 클래스 멤버가 존재하는 시점에는 인스턴스 멤버가 **존재하지 않을** 수 있다.

- `MenberCall`이라는 클래스를 생성하고 그 인스턴스 메소드 `instanceMethod`를 사용해보자.

  - ```
    MemberCall c = new MemberCall();
    int result = c.instanceMethod();
    ```
    위의 방법 말고도 익명의 객체를 생성해서 바로 대입할 수 있다.
    ```
    int result = new MemberCall().instanceMethod();
    ```
    단 위의 방법은 참조변수를 선언하지 않았기 때문에 생성된 `MemberCall`객체는 더 이상 사용할 수 없다.

## 가변인자와 오버로딩

- 가변인자는 `타입... 변수명`과 같이 선언하며 매개변수를 동적으로 지정할 수 있게 한다.

- 가변인자 외에도 매개변수가 더 있다면 가변인자를 매개변수 중 가장 마지막에 선언해야 한다.

- 가변인자를 이용하다보면 오버로딩된 메서드끼리 명확하게 구분이 되지 않는 경우가 있다. 이 경우들을 조심해야 한다.

## 생성자

- 인스턴스가 생성될 때 자동으로 호출된다.

- 클래스 내에 선언되며, **생성자의 이름은 클래스의 이름과 같아야 한다.** 또 **생성자는 리턴 값이 없다.**

- 생성자 또한 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.

- `Card c = new Card();`를 수행하면 일어나는 단계는 다음과 같다.

  1. 연산자 `new`에 의해 `heap`메모리에 `Card`클래스의 인스턴스가 생성된다.

  2. 생성자 `Card()`가 호출되어 수행된다.

  3. 연산자 `new`의 결과로 생성된 `Card`인스턴스의 주소가 반환되어 참조변수 `c`에 저장된다.

- 아무 생성자도 만들지 않으면 컴파일러가 기본적으로 아무 동작도 수행하지 않고 아무 매개변수도 받지 않는 **기본 생성자**를 추가한다.

  - 따라서 매개변수를 받는 생성자를 만들고 인스턴스를 생성할 때 매개변수를 주지 않으면 기본 생성자가 없기에 에러가 난다.

## 생성자에서 다른 생성자 호출하기

1. 호출할 생성자의 이름으로 클래스이름 대신 **this**를 사용한다.

2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

   위의 두 조건을 만족하면 생성자 간에도 서로 호출이 가능하다.

- ```
  class Car{
    String color;
    String gearType;
    int door;

    Car(String color){
      this(color, "auto", 4);
    }

    Car(String color, String gearType, int door){
      this.color = color;
      this.gearType = gearType;
      this.door = door;
    }
  }
  ```

  - 원래 클래스의 멤버 변수들을 초기화할 때는
    ```
    Car(String c, String g, int d){
      color = c;
      gearType = g;
      door = d;
    }
    ```
    위와 같이 `this`키워드를 사용하지 않고도 초기화 할 수 있다. 하지만 지역 변수와 멤버 변수의 이름이 둘 다 `color`로 같은 경우 `this`키워드를 사용하면 멤버 변수를, 그냥 사용하면 지역 변수를 지정한다.

## 생성자를 이용한 인스턴스의 복사

- ```
  Car(Car c){
    color = c.color;
    gearType = c.gearType;
    door = c.door;
  }
  ```
  위와 같이 복사 생성자를 정의하여 사용할 수 있다. `Object`클래스에 정의된 `clone`메서드를 사용하는 방법도 간편하다.

## 변수의 초기화

- 멤버변수와 배열의 초기화는 선택적이지만, **지역변수의 초기화는 필수적이다.**

## 초기화 블럭

- ```
  Car(){
    count++;
    serialNo = count;
    color = "White";
  }
  Car(String color){
    count++;
    serialNo = count;
    this.color = color;
  }
  ```

  위와 같은 상황에서 `count++`과 `serialNo = count`의 경우 다른 생성자인데도 같은 문장이 중복되었다. 이런 상황에서 인스턴스 블럭에 초기화 블럭을 넣어주면 생성자 호출 전에 공통된 초기화를 먼저 진행한다.

  - ```
    {
      count++;
      serialNo = count;
    }
    Car(){
      ...
    }
    ...
    ```

- 클래스 초기화 블럭 또한 사용 가능하며 일반 인스턴스 초기화 블럭 앞에 `static`키워드를 붙이면 된다.

## 멤버변수의 초기화 시기와 순서

- 클래스변수는 클래스가 처음 로딩될 때 단 한 번 초기화 된다.

  - **기본값 -> 명시적초기화 -> 클래스 초기화 블럭**과 같은 순서로 이루어진다.

- 인스턴스변수는 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.

  - **기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자**와 같은 순서로 이루어진다.
